# TBus Protocol Specification

## What is TBus?

TBus is Things Bus which is a software defined bus for Things.
The typical use of TBus is to connect Robots and peripherals including
motors, servos, sensors etc. Like PCI, USB buses, it has the capability of
enumerating the devices on the bus, transferring messages.

For example, using a smart phone to control a robot via Wifi. The App on the
phone connects to the bus (a HTTP or TCP connection over Wifi) as master, and
the Robot also connects to the bus as a bus enumerator, which enumerates
the peripherals (motors, servos, cameras, gyro, accelerometer, etc.), and
the App is able to directly control the peripherals by sending control messages.

In a larger scenario, a service on Internet connects to multiple Robots remotely.
The service itself behaves as a bus enumerator which enumerates connected Robots
as bus enumerators. When the client of the service connects to the bus, it's able
to discover the connected Robots, and control them directly.

Further more, a smart phone (or even a PC) can also be a bus enumerator which
enumerates microphone, speaker, compass, accelerometer, camera, etc.

## Device Addressing and Identification

Each device on the bus is addressed using a bus local address. To send message to
a device connected on a remote bus, the message is encapsulated in a forward message
which addresses the bus enumerator.

Regarding the functionality of a device, like USB device, a class ID and a device
ID are used. The class ID defines the common functionalities in a set of methods
with related data contracts (aka interface in some programming languages). The
device ID defines the device specific functionalities which may support extended
methods.

The message sent from master to device is remote method invocation, and the
message from device master is the result of invocation.

## Transportation

The protocol can work on any 8-bit byte-stream transportation, like serial port,
TCP protocol, WebSocket etc. The transportation is not necessary to be reliable.
Take serial port as example, transfer error is possible. The protocol doesn't
support re-transmission. On application level, it may report error or timeout.

For unreliable transportation like serial port, the transportation layer can optionally
wrap the message with prefix and suffix.

### Message Prefix and Suffix

#### Transmission Error Detection

These prefix/suffix bytes can be used by serial transportation for error detection.

Prefix = 0xa5
Suffix = CheckSum[0:7] CheckSum[8:15] 0x5a

#### Routing

Prefix[7..5] = 0b110
Prefix[4..0] = NumberOf(Addresses)-1

When sent Master-to-Device, it's a routing request, when sent Device-to-Master,
it's routing error.

## Message Format

### Master to device

Field         | Bytes | Content
--------------|-------|--------
Flags         | 1     | message flags
MessageID     | 1-4   | generated by master
BodySize      | 1-2   | shifted body size
[ReqBody]

ReqBody is

Field  | Bytes | Content
-------|-------|--------
Method | 1     | bit[7]: more params, bit[0-6]: method index
Params | n     | method parameters

### Device to master

Field         | Bytes | Content
--------------|-------|--------
Flags         | 1     | message flags
MessageID     | 1-4   | map to received message
BodySize      | 1-2   | shifted body size
[RepBody]

RepBody is

Field    | Bytes | Content
---------|-------|--------
RepFlags | 1     | reply flags
Result   | n     | result

### Flags

Bit | Field     | Content
----|-----------|--------
6-7 | Revision  | 0
4-5 | Encoding  | 0 - Reserved, 1 - ProtoBuf
2-3 | MsgIDSize | 0 - 1 byte, 1 - 2 bytes, 2 - 3 bytes, 3 - 4 bytes
1   | LongBody  | 16-bit body size shifted by 2
0   | Reserved  | 0

### RepFlags

Bit | Field    | Content
----|----------|--------
7   | Error    | 0 - normal, 1 - error and result is encoded error
6   | More     | 0 - last message, 1 - more messages
0-5 | Reserved | 0

### Body Size

The length of body is calculated using:

```
    if Flags.LongBody
        return ((BodySize[1] << 16) | BodySize[0]) << 2
    else
        return BodySize[0] << 1
```

## Device Classes

Each device class has pre-defined list of methods and parameters/responses.
The classes are defined using ProtoBuf services.
